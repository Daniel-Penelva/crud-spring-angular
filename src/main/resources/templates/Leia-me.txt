JpaRepository

A interface `JpaRepository` é uma parte fundamental do Spring Data JPA, que fornece uma abstração de alto nível para realizar operações de 
acesso a dados em bancos de dados relacionais usando a JPA (Java Persistence API). Ela estende a interface `PagingAndSortingRepository` e, 
portanto, herda todos os métodos para operações de CRUD (criação, leitura, atualização e exclusão), além de recursos adicionais.

Aqui estão alguns dos métodos mais comuns fornecidos pela interface `JpaRepository`:

1. `save(entity)`: Salva uma entidade no banco de dados. Se a entidade já existe (com base na chave primária), ela é atualizada; caso contrário, é inserida como um novo registro.

2. `findById(id)`: Busca uma entidade pelo seu identificador (chave primária).

3. `findAll()`: Retorna todas as entidades do tipo especificado.

4. `findAllById(ids)`: Retorna todas as entidades cujos identificadores estão presentes na lista de IDs fornecida.

5. `count()`: Retorna o número total de entidades no banco de dados.

6. `delete(entity)`: Exclui a entidade fornecida do banco de dados.

7. `deleteById(id)`: Exclui uma entidade com base no seu identificador.

8. `deleteAll()`: Exclui todas as entidades do tipo especificado.

9. `flush()`: Sincroniza o contexto de persistência com o banco de dados, garantindo que todas as alterações pendentes sejam efetivadas.

10. `existsById(id)`: Verifica se uma entidade com o identificador fornecido existe no banco de dados.

11. `...`: Além desses métodos, a interface `JpaRepository` herda os métodos de paginação e ordenação da interface `PagingAndSortingRepository`, permitindo a paginação e ordenação dos resultados das consultas.

A interface `JpaRepository` é um componente essencial no ecossistema do Spring Data JPA, facilitando o acesso a dados por meio de operações de 
alto nível e abstraindo muitas das complexidades do trabalho com a JPA. Ao criar uma interface que estende `JpaRepository`, você pode criar 
automaticamente um repositório com todas as operações de CRUD necessárias, além de se beneficiar da resolução automática de consultas baseadas 
em nome e da capacidade de personalizar consultas JPA com facilidade. Isso reduz a quantidade de código boilerplate que você precisa escrever ao 
lidar com operações de banco de dados.

No momento que extends JpaRepository<Long, Course> o Spring vai criar uma implementação dessa interface que já tem os métodos automaticamente
para poder manipular. Ou seja, Agora, quando você cria uma interface de repositório como essa e a configura adequadamente (como definir a 
anotação @Repository ou usar a varredura automática de componentes), o Spring Data JPA fornecerá automaticamente a implementação dos métodos 
CRUD e outras funcionalidades, permitindo que você acesse e manipule dados da entidade Course no banco de dados de forma conveniente e eficiente.

----------------------------------------------------------------------- // -----------------------------------------------------------------------

O import lombok.Data; é uma importação de uma anotação do projeto Lombok, uma biblioteca Java que ajuda a reduzir a verbosidade do código, 
principalmente em classes de modelo, eliminando a necessidade de escrever métodos getters, setters, construtores e outros métodos comuns. A 
anotação @Data é uma das anotações mais utilizadas do Lombok e é frequentemente usada para simplificar a criação de classes de modelo.

Ao usar a anotação @Data, o Lombok gera automaticamente os métodos básicos comuns, como getters, setters, toString, equals e hashCode, com base
nos campos da classe. Isso reduz a quantidade de código repetitivo que você precisa escrever, tornando o código mais limpo e conciso.

No entanto, é importante mencionar que, embora o Lombok seja uma ferramenta poderosa para reduzir a verbosidade do código, você deve usá-lo com 
cautela. Alguns desenvolvedores preferem escrever os métodos manualmente para ter mais controle sobre como esses métodos são implementados e 
para evitar dependências externas em seus projetos.

Certifique-se de adicionar a dependência do Lombok em seu projeto (geralmente no arquivo build.gradle ou pom.xml, dependendo da ferramenta de 
construção que você está usando) e configure sua IDE para reconhecer as anotações do Lombok, para que você possa aproveitar os benefícios dessa
biblioteca.

Biblioteca Maven:
<dependency>
	<groupId>org.projectlombok</groupId>
	<artifactId>lombok</artifactId>
	<optional>true</optional>
</dependency>

----------------------------------------------------------------------- // -----------------------------------------------------------------------

IMPORTANTE!!!!!!!!!

Para resolver o problema do cors vamos criar um proxy no Angular, o objetivo é fazer com que esse proxy funcione como se estivesse fazendo uma 
chamada para o mesmo domínio, não importado que o dominio do back-end (API Spring) e do meu front-end (Angular) sejam diferentes, ou seja, o uso 
do proxy vai fazer com que tenha uma chamada do meu back-end para o meu front-end e vice-versa. Então, vamos criar um arquivo 'proxy.conf.js' na
raiz do projeto.
Também vamos adicionar o package.json vamos fazer a seguinte modificação na propriedade start: 
"start": "ng serve --proxy-config proxy.conf.js"
Essa modificação tem como objetivo que quando o ng serve for gerada vai ser utilizado o proxy. Portanto, sempre que for usar o ng serve, agora teremos 
que utilizar o comando 'npm run start' para que possamos sempre utilizar esse proxy.

Vale ressaltar como estamos utilizando um proxy para resolver os  problemas que viriam com o cors o servidor agora irá ser executado com o 
comando: npm run start (na parte do Angular).

---------- // ----------
Vamos utilizar 'fasterXML' que possui uma biblioteca 'jackson' para fazer o parciamento entre os parâmetros do objeto Curso para Json e vice-versa. Vale ressaltar que a propriedade id
definida no front-end (Angular) está definida da seguinte maneira: _id. Já na nossa API Spring Boot a propriedade está definida como 'id'. Logo, 
repare que as propriedades estão nomeadas de forma diferente, e para resolver isso utilizaremos como foi dito a biblioteca 'jackson'. Essa 
anotação é o @JsonProperty, ela fornecida pela biblioteca Jackson, que é amplamente utilizada para trabalhar com JSON em aplicações Java. Essa 
anotação permite personalizar o mapeamento entre nomes de propriedades de uma classe Java e nomes de campos correspondentes em JSON.

No caso:
 @JsonProperty("_id")
 private String id;

Neste exemplo, a propriedade id na classe Person é mapeada para a chave _id no JSON. Isso significa que, ao serializar um objeto Person em JSON, 
a chave _id será usada no JSON resultante. Da mesma forma, ao desserializar JSON para um objeto Person, o Jackson procurará a chave _id no JSON 
e mapeará seu valor para a propriedade id na classe Java.
A anotação @JsonProperty é especialmente útil quando você precisa trabalhar com APIs RESTful ou outras fontes de dados JSON que usam nomes de 
chaves diferentes daqueles usados em suas classes de modelo Java. Ela ajuda a manter um mapeamento preciso e permite que você tenha um controle
mais granular sobre a serialização e desserialização de dados JSON.

Quando você serializa um objeto Java para JSON ou desserializa JSON para um objeto Java usando o Jackson, os nomes das propriedades na classe Java nem sempre precisam ser idênticos aos nomes das chaves nos objetos JSON. A anotação @JsonProperty permite especificar explicitamente o nome da chave JSON correspondente a uma propriedade específica na classe Java.

E vamos  utilizar a anotação '@ResponseBody é uma anotação fornecida pelo Spring Framework em aplicações Spring MVC que indica que o valor 
retornado por um método de controlador deve ser serializado e incluído diretamente na resposta HTTP como corpo (body) da resposta. Ela é usada 
para indicar que um método de controlador deve retornar o corpo da resposta em vez de redirecionar para uma visualização (view).
Quando você adiciona a anotação @ResponseBody a um método de controlador, o Spring MVC assume que o valor retornado deve ser convertido em um 
formato apropriado, como JSON, XML ou outros, dependendo da configuração da aplicação e do cabeçalho Accept da solicitação HTTP.

A anotação @ResponseBody é frequentemente usada em conjunto com a anotação @RestController, que combina a funcionalidade de @Controller e 
@ResponseBody, permitindo que você crie facilmente APIs RESTful em sua aplicação Spring.

----------------------------------------------------------------------- // -----------------------------------------------------------------------

No método HTTP DELETE além de poder declarar o tipo Void, também podemos declarar o tipo Object e ? (espera qualquer tipo). 

Podemos fazer assim:

@DeleteMapping("/{id}")
    public ResponseEntity<Object> delete(@PathVariable Long id){
        return courseRepository.findById(id)
            .map(recordFound -> {
                courseRepository.deleteById(id);
                return ResponseEntity.noContent().build();
            })
            .orElse(ResponseEntity.notFound().build());
}

ou, podemos fazer assim:

	@DeleteMapping("/{id}")
    public ResponseEntity<?> delete(@PathVariable Long id){
        return courseRepository.findById(id)
            .map(recordFound -> {
                courseRepository.deleteById(id);
                return ResponseEntity.noContent().build();
            })
            .orElse(ResponseEntity.notFound().build());
    }

----------------------------------------------------------------------- // -----------------------------------------------------------------------

Validações da API com Java Bean Validation

Exemplos da documentação Bean Validation:
Link: https://docs.jboss.org/hibernate/beanvalidation/spec/2.0/api/

As anotações `@Validated` e `@Valid` são usadas em aplicações Spring Framework, que é um framework para o desenvolvimento de aplicativos Java, 
para validar os dados de entrada de formulários ou objetos antes de processá-los. No entanto, elas têm usos e escopos ligeiramente diferentes. 

Explicando cada uma delas:

1. @Validated:

   - `@Validated` é uma anotação específica do Spring, usada para indicar que uma classe ou método deve ser validado. Pode ser aplicada a nível 
      de classe ou a nível de método. Quando você usa `@Validated` em uma classe ou método, o Spring ativa a validação para os argumentos e 
      parâmetros do método e qualquer objeto aninhado.

   - Você pode personalizar a validação em classes marcadas com `@Validated` usando grupos de validação e especificar quais grupos de validação 
     devem ser aplicados.

   - `@Validated` é frequentemente usado em métodos de controladores do Spring (controladores MVC) para validar dados de entrada de formulários 
      antes de processá-los.

   Exemplo:

   ```java
   @RestController
   public class UserController {
       @PostMapping("/users")
       public ResponseEntity<User> createUser(@Validated @RequestBody User user) {
           // ...
       }
   }
   ```

   Neste exemplo, `@Validated` é usado para validar o objeto `User` que é enviado como parte da solicitação HTTP antes de processá-lo.

2. @Valid:

   - `@Valid` é uma anotação padrão do Java e é usada em conjunto com `@RequestBody` ou `@ModelAttribute` em métodos de controladores do Spring 
      para indicar que o objeto sendo passado como parâmetro deve ser validado.

   - Quando `@Valid` é aplicado a um parâmetro, o Spring ativa a validação do objeto especificado pelo Bean Validation (geralmente usando 
     anotações como `@NotNull`, `@Size`, `@Pattern`, etc.) antes de processar a solicitação.

   Exemplo:

   ```java
   @RestController
   public class UserController {
       @PostMapping("/users")
       public ResponseEntity<User> createUser(@Valid @RequestBody User user) {
           // ...
       }
   }
   ```

   Neste exemplo, `@Valid` é usado para validar o objeto `User` antes de processar a solicitação HTTP.

Ambas as anotações, `@Validated` e `@Valid`, têm o objetivo de garantir que os dados de entrada estejam em conformidade com as regras de 
validação especificadas antes de serem processados pelo controlador do Spring. A principal diferença está na forma como são usadas e nas 
personalizações que podem ser aplicadas com `@Validated`. Em ambos os casos, as violações das regras de validação podem resultar em exceções, 
que podem ser manipuladas e tratadas adequadamente no código do controlador.

--------------- // ---------------

Anotação `@Pattern`

A anotação `@Pattern` é uma anotação usada em muitos frameworks Java, como o Spring Framework, para aplicar validações a campos de uma classe ou 
objeto. Ela é usada para garantir que um determinado campo contenha um valor que corresponda a um padrão regular expresso.

```java
@Pattern(regexp = "Back-end|Front-end")
```

Essa anotação está sendo aplicada no campo category e especifica que o valor desse campo deve corresponder a uma das duas opções: "Back-end" ou 
"Front-end". O `regexp` (expressão regular) define o padrão ao qual o valor do campo deve corresponder. No entanto, em vez de usar uma expressão 
regular complexa, esta anotação simplesmente verifica se o valor é uma das duas strings fornecidas.

OBS. Vale ressaltar que o valor "Back-end" ou "Front-end" possui sensitivity-case, ou seja, tem que ser escrito da mesma maneira, senão o Validated
não vai validar o valor.

Isso significa que, se o campo for uma String, ele só será válido se conter "Back-end" ou "Front-end". Qualquer outra entrada não será 
considerada válida. Por exemplo:

- Se o campo tiver o valor "Back-end", a validação será bem-sucedida.
- Se o campo tiver o valor "Front-end", a validação também será bem-sucedida.
- Se o campo tiver qualquer outro valor, a validação falhará.

Essa anotação é útil para garantir que os dados inseridos ou enviados atendam a critérios específicos e é frequentemente usada para validar campos 
em formulários ou objetos de transferência de dados. Ela ajuda a garantir a integridade dos dados que entram no sistema.

----------------------------------------------------------------------- // -----------------------------------------------------------------------

Soft Delete (Remoção Lógica)

O conceito de "Soft Delete" ou "Remoção Lógica" é uma técnica comum no desenvolvimento de software para gerenciar registros de dados de forma a 
permitir a recuperação de itens excluídos, em oposição à exclusão física, onde os registros são permanentemente removidos do banco de dados. 

Pontos importantes sobre o Soft Delete:

1.O que é Soft Delete?
   O Soft Delete é uma abordagem que envolve adicionar um campo adicional a uma tabela de banco de dados, geralmente chamado de "deleted_at" ou
   "status" ou algo semelhante, que armazena a data e hora em que um registro foi marcado como excluído. Em vez de remover fisicamente o registro, 
   você apenas atualiza esse campo para indicar que o registro está inativo.

2.Vantagens do Soft Delete:
   - Recuperação de dados: A principal vantagem do Soft Delete é a capacidade de recuperar dados excluídos acidentalmente ou intencionalmente. 
     Isso pode ser útil em situações em que você precisa manter um histórico de alterações ou atender a requisitos regulatórios.

   - Auditoria e rastreamento: O Soft Delete permite rastrear quem e quando um registro foi excluído, o que pode ser útil para fins de auditoria 
     e responsabilização.

   - Migrações de dados mais seguras: Quando você precisa fazer alterações em seu esquema de banco de dados, o Soft Delete simplifica o processo, 
     pois você não precisa se preocupar em migrar dados excluídos.

3. Desvantagens do Soft Delete:
   - Consumo de espaço em disco: Os registros marcados como excluídos ainda ocupam espaço no banco de dados, o que pode ser uma preocupação se 
     você estiver lidando com uma grande quantidade de dados.

   - Complexidade: Implementar o Soft Delete pode adicionar complexidade ao seu código, uma vez que você deve sempre levar em consideração os 
     registros marcados como excluídos em suas consultas.

4. Exemplos de implementação:
   A implementação do Soft Delete varia dependendo do sistema de gerenciamento de banco de dados (DBMS) que você está usando e da linguagem de 
   programação. Aqui está um exemplo simples usando SQL:

   ```sql
   -- Tabela de exemplo
   CREATE TABLE users (
       id INT PRIMARY KEY,
       username VARCHAR(50),
       deleted_at DATETIME
   );

   -- Marcar um registro como excluído
   UPDATE users SET deleted_at = NOW() WHERE id = 1;

   -- Recuperar registros excluídos
   SELECT * FROM users WHERE deleted_at IS NOT NULL;

   -- Restaurar um registro excluído
   UPDATE users SET deleted_at = NULL WHERE id = 1;
   ```

Em resumo, o Soft Delete é uma abordagem valiosa para gerenciar registros de dados de forma que você possa manter um histórico de alterações e 
recuperar dados excluídos quando necessário. No entanto, é importante considerar cuidadosamente os prós e contras e decidir se é apropriado para 
o seu caso de uso específico.


No meu exemplo, a tabela curso existe um campo status que pode ser definido como Ativo ou Inativo. O status Ativo significa que o registro não 
sofreu um Soft Delete, já o status Inativo significa que o registro sofreu um Soft Delete. Ou seja, digamos que o usuário remova o curso CSS e 
ao ir no banco de dados vai ser visualizado que o registro NÃO FOI REMOVIDO DO BANCO DE DADOS, o conceito Soft Delete garante que o registro 
permaneça persistido no banco, porém o campo status vai estar com o valor Inativo, o que significa que registrou que esse curso foi 
marcado como excluído. E essa funcionalidade é feita de uma forma bem simples, utilizando a anotação @SqlDelete do Hibernate.

A anotação `@SQLDelete` é um recurso comum em frameworks de mapeamento objeto-relacional (ORM), como o Hibernate, que é usado para personalizar 
a instrução SQL usada para realizar uma exclusão lógica (Soft Delete) em um registro de banco de dados.

A anotação `@SQLDelete` permite que substitua a instrução SQL padrão usada pelo ORM para marcar um registro como excluído (inativo) quando o 
método de exclusão é chamado. No meu exemplo, a anotação `@SQLDelete` está sendo usada para especificar a instrução SQL personalizada que será 
executada quando um registro da entidade "Course" for marcado como "Inativo."

Explicação mais detalhada do exemplo:

```java
@SQLDelete(sql = "UPDATE Course SET status = 'Inativo' WHERE id = ?")
```

- `@SQLDelete` é a anotação que indica que a instrução SQL personalizada está sendo definida.

- `sql` é o atributo dentro da anotação `@SQLDelete` que permite especificar a instrução SQL personalizada que será executada quando um registro 
   da entidade for excluído logicamente.

- A instrução SQL personalizada especificada no exemplo é um comando `UPDATE`. Ele define que, em vez de excluir fisicamente o registro da 
  tabela "Course," o status desse registro será definido como "Inativo." O `?` na instrução SQL é um espaço reservado para o ID do curso que está 
  sendo excluído. Isso permite que o ORM insira o valor correto do ID ao executar a operação de exclusão lógica.

Com essa configuração, quando chamar o método de exclusão para um objeto da classe "Course," o ORM usará essa instrução SQL personalizada para 
marcar o registro como "Inativo" em vez de excluí-lo fisicamente do banco de dados.

Essa é uma maneira poderosa de personalizar o comportamento de exclusão lógica em um ORM e ajustá-lo de acordo com os requisitos específicos do 
aplicativo, como definir um status de exclusão ou manter um histórico de alterações em registros excluídos.

--------------- // ---------------

Bom Saber: Que tal um requisito proposto. Agora se buscarmos os registros de cursos vai ser listado todos os registros de cursos seja ele o ativo 
ou inativo, e no caso, não queremos buscar os cursos que estejam com o status de inativo, logo precisaremos filtar os registro que estejam inativos.
Para fazer esse filtro vai ser utilizado a anotação @Where que terá como funcionalidade a seguinte função, toda vez que for feito o select no 
banco de dados, o Hibernate automaticamente irá adicionar o filtro <clause = "status = 'Ativo'"> na cláusula Where.

A anotação `@Where` é uma anotação usada em frameworks de mapeamento objeto-relacional (ORM), como o Hibernate, para definir uma cláusula de 
restrição (filtro) que afeta todas as consultas feitas em uma entidade específica. No exemplo que eu forneci, a anotação `@Where` está sendo 
usada para filtrar automaticamente registros com o status "Ativo" sempre que uma consulta for realizada na entidade à qual a anotação é aplicada.

Explicação mais detalhada:

```java
@Where(clause = "status = 'Ativo'")
```

- `@Where` é a anotação usada para definir a cláusula de restrição (filtro) que será aplicada a todas as consultas realizadas na entidade 
  associada.

- `clause` é o atributo da anotação `@Where` onde especifica a condição que será aplicada como filtro. No exemplo, a condição é "status = 'Ativo'". 
   Isso significa que, sempre que uma consulta for feita na entidade que possui essa anotação, apenas os registros com o status igual a "Ativo" 
   serão retornados.

Essa anotação é útil quando deseja garantir que apenas registros ativos sejam retornados em todas as consultas sem a necessidade de especificar 
a cláusula `WHERE` manualmente em todas as consultas. Ela simplifica o código e ajuda a manter a consistência nos resultados retornados.

É importante observar que a anotação `@Where` é eficaz apenas quando consultas são feitas por meio do ORM que oferece suporte a essa 
funcionalidade, como o Hibernate. Ela não afeta consultas SQL feitas diretamente no banco de dados sem o uso do ORM.

Em resumo, a anotação `@Where` é uma maneira conveniente de definir automaticamente um filtro para registros ativos em uma entidade, tornando 
mais fácil recuperar apenas os dados relevantes em todas as consultas relacionadas a essa entidade.



